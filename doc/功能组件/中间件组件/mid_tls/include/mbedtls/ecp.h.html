

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
    <style>
    /* base */
    html,
    body,
    .container {
      width: 100%;
      height: 100%;
    }

    a,
    a:link,
    a:visited {
      text-decoration: none;
      color: inherit;
    }

    ul {
      list-style: none;
    }

    *,
    ::before,
    ::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    *:focus {
      outline: 0;
    }

    .container {
      display: flex;
      padding-top: 20px;
    }

    /* Nav */
    .container .doc-nav {
      position: fixed;
      height: 100%;
      margin: 0 30px 0 40px;
      width: 280px;
    }

    .doc-nav .nav-header {
      display: flex;
      align-items: center;
      box-sizing: border-box;
      background-color: rgb(240, 241, 242);
      height: 40px;
      padding: 16px;
      font-size: 18px;
      font-weight: 500;
      color: rgb(62, 64, 66);
      cursor: pointer;
    }

    .doc-nav .nav-content {
      height: calc(100% - 40px);
      overflow-y: auto;
      color: rgb(32, 34, 36);
    }

    .doc-nav .nav-content .nav-list,
    .doc-nav .nav-content .nav-sub-list {
      line-height: 1.5rem;
    }

    .doc-nav .nav-content .nav-label {
      display: inline-block;
      position: relative;
      padding: 2px 0 2px 20px;
      margin-bottom: 4px;
    }

    .doc-nav .nav-content .nav-sub-label {
      position: relative;
      padding: 2px 0 2px 40px;
      font-size: 14px;
    }

    .doc-nav .nav-content .nav-sub-label:hover {
      text-decoration: underline;
    }

    .doc-nav .nav-content .nav-list .nav-label.group::before {
      border-bottom: 0.25rem solid transparent;
      border-left: 0.25rem solid #6e7072;
      border-right: 0;
      border-top: 0.25rem solid transparent;
      content: '';
      display: block;
      height: 0;
      left: 0.5rem;
      position: absolute;
      top: 0.625rem;
      transition: transform 0.1s linear;
      width: 0;
    }

    .doc-nav .nav-content .nav-list .nav-label.group.active::before {
      transform: rotate(90deg);
    }

    /* doc content */
    .container .doc-content {
      position: fixed;
      height: 100%;
      width: calc(100% - 80px - 40px - 30px - 240px);
      right: 0%;
      overflow-y: auto;
    }

    .doc-title {
      border-bottom: 1px solid #dcdee0;
      font-size: 22px;
      margin: 8px 0 0;
      padding-bottom: 16px;
    }

    .doc-content h3 {
      font-size: 24px;
      font-weight: 600;
      margin: 24px 0;
    }

    .doc-content h4 {
      font-size: 22px;
      font-weight: 500;
      margin: 30px 0 8px;
    }

    .doc-content h4 span {
      color: #007d9c;
    }

    .doc-content .doc-declare {
      background-color: #fafafa;
      border-radius: 5px;
      border: 1px solid #ccc;
      font-size: 14px;
      overflow-x: auto;
      padding: 10px;
      tab-size: 4;
      line-height: 20px;
    }

    .doc-content .doc-comment {
      font-size: 16px;
      margin: 16px 0;
      line-height: 24px;
      word-break: break-word;
    }
  </style>

</head>
<body>
  <div class="container">
    <div class="doc-nav">
      <a href="#Documentation" class="nav-header">Documentation</a>
      <nav class="nav-content">
        <ul class="nav-list">
          <li>
            <a href="#includes" class="nav-label">Includes</a>
             
            <ul class="nav-sub-list">

              <li>
                <a href="#config.h" class="nav-sub-label">config.h</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_CONFIG_FILE" class="nav-sub-label">MBEDTLS_CONFIG_FILE</a>
              </li>
      

              <li>
                <a href="#bignum.h" class="nav-sub-label">bignum.h</a>
              </li>
      

              <li>
                <a href="#ecp_alt.h" class="nav-sub-label">ecp_alt.h</a>
              </li>
      
            </ul>
            
          </li>
          <li>
            <a href="#macros" class="nav-label">Macros</a>
             
            <ul class="nav-sub-list">

              <li>
                <a href="#MBEDTLS_ECP_H" class="nav-sub-label">MBEDTLS_ECP_H</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ERR_ECP_BAD_INPUT_DATA" class="nav-sub-label">MBEDTLS_ERR_ECP_BAD_INPUT_DATA</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL" class="nav-sub-label">MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE" class="nav-sub-label">MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ERR_ECP_VERIFY_FAILED" class="nav-sub-label">MBEDTLS_ERR_ECP_VERIFY_FAILED</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ERR_ECP_ALLOC_FAILED" class="nav-sub-label">MBEDTLS_ERR_ECP_ALLOC_FAILED</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ERR_ECP_RANDOM_FAILED" class="nav-sub-label">MBEDTLS_ERR_ECP_RANDOM_FAILED</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ERR_ECP_INVALID_KEY" class="nav-sub-label">MBEDTLS_ERR_ECP_INVALID_KEY</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH" class="nav-sub-label">MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ERR_ECP_HW_ACCEL_FAILED" class="nav-sub-label">MBEDTLS_ERR_ECP_HW_ACCEL_FAILED</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ERR_ECP_IN_PROGRESS" class="nav-sub-label">MBEDTLS_ERR_ECP_IN_PROGRESS</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ECP_DP_MAX" class="nav-sub-label">MBEDTLS_ECP_DP_MAX</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ECP_MAX_BITS" class="nav-sub-label">MBEDTLS_ECP_MAX_BITS</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ECP_MAX_BYTES" class="nav-sub-label">MBEDTLS_ECP_MAX_BYTES</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ECP_MAX_PT_LEN" class="nav-sub-label">MBEDTLS_ECP_MAX_PT_LEN</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ECP_WINDOW_SIZE" class="nav-sub-label">MBEDTLS_ECP_WINDOW_SIZE</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ECP_FIXED_POINT_OPTIM" class="nav-sub-label">MBEDTLS_ECP_FIXED_POINT_OPTIM</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ECP_OPS_CHK" class="nav-sub-label">MBEDTLS_ECP_OPS_CHK</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ECP_OPS_DBL" class="nav-sub-label">MBEDTLS_ECP_OPS_DBL</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ECP_OPS_ADD" class="nav-sub-label">MBEDTLS_ECP_OPS_ADD</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ECP_OPS_INV" class="nav-sub-label">MBEDTLS_ECP_OPS_INV</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ECP_BUDGET( ops )" class="nav-sub-label">MBEDTLS_ECP_BUDGET( ops )</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ECP_BUDGET( ops )" class="nav-sub-label">MBEDTLS_ECP_BUDGET( ops )</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ECP_PF_UNCOMPRESSED" class="nav-sub-label">MBEDTLS_ECP_PF_UNCOMPRESSED</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ECP_PF_COMPRESSED" class="nav-sub-label">MBEDTLS_ECP_PF_COMPRESSED</a>
              </li>
      

              <li>
                <a href="#MBEDTLS_ECP_TLS_NAMED_CURVE" class="nav-sub-label">MBEDTLS_ECP_TLS_NAMED_CURVE</a>
              </li>
      
            </ul>
            
          </li>
          <li>
            <a href="#functions" class="nav-label">Functions</a>
             
            <ul class="nav-sub-list">

              <li>
                <a href="#mbedtls_ecp_check_budget" class="nav-sub-label">mbedtls_ecp_check_budget</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_set_max_ops" class="nav-sub-label">mbedtls_ecp_set_max_ops</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_restart_is_enabled" class="nav-sub-label">mbedtls_ecp_restart_is_enabled</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_point_init" class="nav-sub-label">mbedtls_ecp_point_init</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_group_init" class="nav-sub-label">mbedtls_ecp_group_init</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_keypair_init" class="nav-sub-label">mbedtls_ecp_keypair_init</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_point_free" class="nav-sub-label">mbedtls_ecp_point_free</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_group_free" class="nav-sub-label">mbedtls_ecp_group_free</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_keypair_free" class="nav-sub-label">mbedtls_ecp_keypair_free</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_restart_init" class="nav-sub-label">mbedtls_ecp_restart_init</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_restart_free" class="nav-sub-label">mbedtls_ecp_restart_free</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_copy" class="nav-sub-label">mbedtls_ecp_copy</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_group_copy" class="nav-sub-label">mbedtls_ecp_group_copy</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_set_zero" class="nav-sub-label">mbedtls_ecp_set_zero</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_is_zero" class="nav-sub-label">mbedtls_ecp_is_zero</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_point_cmp" class="nav-sub-label">mbedtls_ecp_point_cmp</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_point_read_string" class="nav-sub-label">mbedtls_ecp_point_read_string</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_point_write_binary" class="nav-sub-label">mbedtls_ecp_point_write_binary</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_point_read_binary" class="nav-sub-label">mbedtls_ecp_point_read_binary</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_tls_read_point" class="nav-sub-label">mbedtls_ecp_tls_read_point</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_tls_write_point" class="nav-sub-label">mbedtls_ecp_tls_write_point</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_group_load" class="nav-sub-label">mbedtls_ecp_group_load</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_tls_read_group" class="nav-sub-label">mbedtls_ecp_tls_read_group</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_tls_read_group_id" class="nav-sub-label">mbedtls_ecp_tls_read_group_id</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_tls_write_group" class="nav-sub-label">mbedtls_ecp_tls_write_group</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_mul" class="nav-sub-label">mbedtls_ecp_mul</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_mul_restartable" class="nav-sub-label">mbedtls_ecp_mul_restartable</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_muladd" class="nav-sub-label">mbedtls_ecp_muladd</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_muladd_restartable" class="nav-sub-label">mbedtls_ecp_muladd_restartable</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_check_pubkey" class="nav-sub-label">mbedtls_ecp_check_pubkey</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_check_privkey" class="nav-sub-label">mbedtls_ecp_check_privkey</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_gen_privkey" class="nav-sub-label">mbedtls_ecp_gen_privkey</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_gen_keypair_base" class="nav-sub-label">mbedtls_ecp_gen_keypair_base</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_gen_keypair" class="nav-sub-label">mbedtls_ecp_gen_keypair</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_gen_key" class="nav-sub-label">mbedtls_ecp_gen_key</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_check_pub_priv" class="nav-sub-label">mbedtls_ecp_check_pub_priv</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_self_test" class="nav-sub-label">mbedtls_ecp_self_test</a>
              </li>
      
            </ul>
            
          </li>
          <li>
            <a href="#vars" class="nav-label">Vars</a>
            
            <ul class="nav-sub-list">
            
            </ul>
            
          </li>
          <li>
            <a href="#consts" class="nav-label">Consts</a>
             
            <ul class="nav-sub-list">

              <li>
                <a href="# " class="nav-sub-label"> </a>
              </li>
      

              <li>
                <a href="# " class="nav-sub-label"> </a>
              </li>
      

              <li>
                <a href="# " class="nav-sub-label"> </a>
              </li>
      

              <li>
                <a href="# " class="nav-sub-label"> </a>
              </li>
      

              <li>
                <a href="# " class="nav-sub-label"> </a>
              </li>
      
            </ul>
            
          </li>
          <li>
            <a href="#types" class="nav-label">Types</a>
            
            <ul class="nav-sub-list">
            
            </ul>
            
          </li>
          <li>
            <a href="#typedefs" class="nav-label">Typedefs</a>
             
            <ul class="nav-sub-list">

              <li>
                <a href="#mbedtls_ecp_group_id;
" class="nav-sub-label">mbedtls_ecp_group_id;
</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_curve_info;
" class="nav-sub-label">mbedtls_ecp_curve_info;
</a>
              </li>
      

              <li>
                <a href="#
mbedtls_ecp_point;
" class="nav-sub-label">
mbedtls_ecp_point;
</a>
              </li>
      

              <li>
                <a href="#
mbedtls_ecp_group;
" class="nav-sub-label">
mbedtls_ecp_group;
</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_restart_mul_ctx" class="nav-sub-label">mbedtls_ecp_restart_mul_ctx</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_restart_muladd_ctx" class="nav-sub-label">mbedtls_ecp_restart_muladd_ctx</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_restart_ctx;
" class="nav-sub-label">mbedtls_ecp_restart_ctx;
</a>
              </li>
      

              <li>
                <a href="#mbedtls_ecp_restart_ctx" class="nav-sub-label">mbedtls_ecp_restart_ctx</a>
              </li>
      

              <li>
                <a href="#
mbedtls_ecp_keypair;
" class="nav-sub-label">
mbedtls_ecp_keypair;
</a>
              </li>
      
            </ul>
            
          </li>
        </ul>
      </nav>
    </div>
    <div class="doc-content">
      <h2 id="Documentation" class="doc-title">Documentation</h2>
      <h3 id="includes">Includes</h3>
      

      <h4 id="config.h"><span>config.h</span></h4>
      <pre class="doc-declare"><code>#include "config.h"
</code></pre>
      <pre class="doc-comment">#include "config.h"
</pre>

      <h4 id="MBEDTLS_CONFIG_FILE"><span>MBEDTLS_CONFIG_FILE</span></h4>
      <pre class="doc-declare"><code>#include MBEDTLS_CONFIG_FILE
</code></pre>
      <pre class="doc-comment">#include MBEDTLS_CONFIG_FILE
</pre>

      <h4 id="bignum.h"><span>bignum.h</span></h4>
      <pre class="doc-declare"><code>#include "bignum.h"
</code></pre>
      <pre class="doc-comment">#include "bignum.h"
</pre>

      <h4 id="ecp_alt.h"><span>ecp_alt.h</span></h4>
      <pre class="doc-declare"><code>#include "ecp_alt.h"
</code></pre>
      <pre class="doc-comment">#include "ecp_alt.h"
</pre>
      <h3 id="macros">Macros</h3>
      

      <h4 id="MBEDTLS_ECP_H">Marco <span>MBEDTLS_ECP_H</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ECP_H
</code></pre>
      <pre class="doc-comment"></pre>

      <h4 id="MBEDTLS_ERR_ECP_BAD_INPUT_DATA">Marco <span>MBEDTLS_ERR_ECP_BAD_INPUT_DATA</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ERR_ECP_BAD_INPUT_DATA                   -20352 /**< Bad input parameters to function. */
</code></pre>
      <pre class="doc-comment">/*
 * ECP error codes
 */</pre>

      <h4 id="MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL">Marco <span>MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL                 -20224 /**< The buffer is too small to write to. */
</code></pre>
      <pre class="doc-comment"></pre>

      <h4 id="MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE">Marco <span>MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE              -4E80 /**< The requested feature is not available, for example, the requested curve is not supported. */
</code></pre>
      <pre class="doc-comment"></pre>

      <h4 id="MBEDTLS_ERR_ECP_VERIFY_FAILED">Marco <span>MBEDTLS_ERR_ECP_VERIFY_FAILED</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ERR_ECP_VERIFY_FAILED                    -4E00 /**< The signature is not valid. */
</code></pre>
      <pre class="doc-comment"></pre>

      <h4 id="MBEDTLS_ERR_ECP_ALLOC_FAILED">Marco <span>MBEDTLS_ERR_ECP_ALLOC_FAILED</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ERR_ECP_ALLOC_FAILED                     -4D80 /**< Memory allocation failed. */
</code></pre>
      <pre class="doc-comment"></pre>

      <h4 id="MBEDTLS_ERR_ECP_RANDOM_FAILED">Marco <span>MBEDTLS_ERR_ECP_RANDOM_FAILED</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ERR_ECP_RANDOM_FAILED                    -4D00 /**< Generation of random value, such as ephemeral key, failed. */
</code></pre>
      <pre class="doc-comment"></pre>

      <h4 id="MBEDTLS_ERR_ECP_INVALID_KEY">Marco <span>MBEDTLS_ERR_ECP_INVALID_KEY</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ERR_ECP_INVALID_KEY                      -4C80 /**< Invalid private or public key. */
</code></pre>
      <pre class="doc-comment"></pre>

      <h4 id="MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH">Marco <span>MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH                 -4C00 /**< The buffer contains a valid signature followed by more data. */
</code></pre>
      <pre class="doc-comment"></pre>

      <h4 id="MBEDTLS_ERR_ECP_HW_ACCEL_FAILED">Marco <span>MBEDTLS_ERR_ECP_HW_ACCEL_FAILED</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ERR_ECP_HW_ACCEL_FAILED                  -4B80 /**< The ECP hardware accelerator failed. */
</code></pre>
      <pre class="doc-comment">/* MBEDTLS_ERR_ECP_HW_ACCEL_FAILED is deprecated and should not be used. */</pre>

      <h4 id="MBEDTLS_ERR_ECP_IN_PROGRESS">Marco <span>MBEDTLS_ERR_ECP_IN_PROGRESS</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ERR_ECP_IN_PROGRESS                      -4B00 /**< Operation in progress, call again with the same parameters to continue. */
</code></pre>
      <pre class="doc-comment"></pre>

      <h4 id="MBEDTLS_ECP_DP_MAX">Marco <span>MBEDTLS_ECP_DP_MAX</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ECP_DP_MAX    12
</code></pre>
      <pre class="doc-comment">/**
 * The number of supported curves, plus one for #MBEDTLS_ECP_DP_NONE.
 *
 * \note Montgomery curves are currently excluded.
 */</pre>

      <h4 id="MBEDTLS_ECP_MAX_BITS">Marco <span>MBEDTLS_ECP_MAX_BITS</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ECP_MAX_BITS    521  /**< The maximum size of groups, in bits. */
</code></pre>
      <pre class="doc-comment">/**
 * The maximum size of the groups, that is, of \c N and \c P.
 */</pre>

      <h4 id="MBEDTLS_ECP_MAX_BYTES">Marco <span>MBEDTLS_ECP_MAX_BYTES</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ECP_MAX_BYTES   ( ( MBEDTLS_ECP_MAX_BITS + 7 ) / 8 )
</code></pre>
      <pre class="doc-comment"></pre>

      <h4 id="MBEDTLS_ECP_MAX_PT_LEN">Marco <span>MBEDTLS_ECP_MAX_PT_LEN</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ECP_MAX_PT_LEN  ( 2 * MBEDTLS_ECP_MAX_BYTES + 1 )
</code></pre>
      <pre class="doc-comment"></pre>

      <h4 id="MBEDTLS_ECP_WINDOW_SIZE">Marco <span>MBEDTLS_ECP_WINDOW_SIZE</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ECP_WINDOW_SIZE   6  /**< The maximum window size used. */
</code></pre>
      <pre class="doc-comment">/*
 * Maximum "window" size used for point multiplication.
 * Default: 6.
 * Minimum value: 2. Maximum value: 7.
 *
 * Result is an array of at most ( 1 << ( MBEDTLS_ECP_WINDOW_SIZE - 1 ) )
 * points used for point multiplication. This value is directly tied to EC
 * peak memory usage, so decreasing it by one should roughly cut memory usage
 * by two (if large curves are in use).
 *
 * Reduction in size may reduce speed, but larger curves are impacted first.
 * Sample performances (in ECDHE handshakes/s, with FIXED_POINT_OPTIM = 1):
 *      w-size:     6       5       4       3       2
 *      521       145     141     135     120      97
 *      384       214     209     198     177     146
 *      256       320     320     303     262     226
 *      224       475     475     453     398     342
 *      192       640     640     633     587     476
 */</pre>

      <h4 id="MBEDTLS_ECP_FIXED_POINT_OPTIM">Marco <span>MBEDTLS_ECP_FIXED_POINT_OPTIM</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ECP_FIXED_POINT_OPTIM 1  /**< Enable fixed-point speed-up. */
</code></pre>
      <pre class="doc-comment">/*
 * Trade memory for speed on fixed-point multiplication.
 *
 * This speeds up repeated multiplication of the generator (that is, the
 * multiplication in ECDSA signatures, and half of the multiplications in
 * ECDSA verification and ECDHE) by a factor roughly 3 to 4.
 *
 * The cost is increasing EC peak memory usage by a factor roughly 2.
 *
 * Change this value to 0 to reduce peak memory usage.
 */</pre>

      <h4 id="MBEDTLS_ECP_OPS_CHK">Marco <span>MBEDTLS_ECP_OPS_CHK</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ECP_OPS_CHK  3 /*!< basic ops count for ecp_check_pubkey()  */
</code></pre>
      <pre class="doc-comment">/*
 * Operation counts for restartable functions
 */</pre>

      <h4 id="MBEDTLS_ECP_OPS_DBL">Marco <span>MBEDTLS_ECP_OPS_DBL</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ECP_OPS_DBL  8 /*!< basic ops count for ecp_double_jac()    */
</code></pre>
      <pre class="doc-comment"></pre>

      <h4 id="MBEDTLS_ECP_OPS_ADD">Marco <span>MBEDTLS_ECP_OPS_ADD</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ECP_OPS_ADD 11 /*!< basic ops count for see ecp_add_mixed() */
</code></pre>
      <pre class="doc-comment"></pre>

      <h4 id="MBEDTLS_ECP_OPS_INV">Marco <span>MBEDTLS_ECP_OPS_INV</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ECP_OPS_INV 120 /*!< empirical equivalent for mpi_mod_inv()  */
</code></pre>
      <pre class="doc-comment"></pre>

      <h4 id="MBEDTLS_ECP_BUDGET( ops )">Marco <span>MBEDTLS_ECP_BUDGET( ops )</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ECP_BUDGET( ops )  \
   MBEDTLS_MPI_CHK( mbedtls_ecp_check_budget( grp, rs_ctx, \
                                              (unsigned) (ops) ) );
</code></pre>
      <pre class="doc-comment">/* Utility macro for checking and updating ops budget */</pre>

      <h4 id="MBEDTLS_ECP_BUDGET( ops )">Marco <span>MBEDTLS_ECP_BUDGET( ops )</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ECP_BUDGET( ops )  /* no-op; for compatibility */
</code></pre>
      <pre class="doc-comment"></pre>

      <h4 id="MBEDTLS_ECP_PF_UNCOMPRESSED">Marco <span>MBEDTLS_ECP_PF_UNCOMPRESSED</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ECP_PF_UNCOMPRESSED   0  /**< Uncompressed point format. */
</code></pre>
      <pre class="doc-comment">/*
 * Point formats, from RFC 4492's enum ECPointFormat
 */</pre>

      <h4 id="MBEDTLS_ECP_PF_COMPRESSED">Marco <span>MBEDTLS_ECP_PF_COMPRESSED</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ECP_PF_COMPRESSED     1  /**< Compressed point format. */
</code></pre>
      <pre class="doc-comment"></pre>

      <h4 id="MBEDTLS_ECP_TLS_NAMED_CURVE">Marco <span>MBEDTLS_ECP_TLS_NAMED_CURVE</span></h4>
      <pre class="doc-declare"><code>#define MBEDTLS_ECP_TLS_NAMED_CURVE   3  /**< The named_curve of ECCurveType. */
</code></pre>
      <pre class="doc-comment">/*
 * Some other constants from RFC 4492
 */</pre>
      <h3 id="functions">Functions</h3>
      

      <h4 id="mbedtls_ecp_check_budget">Func <span>mbedtls_ecp_check_budget</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_check_budget( const mbedtls_ecp_group *grp,
                             mbedtls_ecp_restart_ctx *rs_ctx,
                             unsigned ops );</code></pre>
      <pre class="doc-comment">/**
 * \brief           Internal; for restartable functions in other modules.
 *                  Check and update basic ops budget.
 *
 * \param grp       Group structure
 * \param rs_ctx    Restart context
 * \param ops       Number of basic ops to do
 *
 * \return          \c 0 if doing \p ops basic ops is still allowed,
 * \return          #MBEDTLS_ERR_ECP_IN_PROGRESS otherwise.
 */</pre>

      <h4 id="mbedtls_ecp_set_max_ops">Func <span>mbedtls_ecp_set_max_ops</span></h4>
      <pre class="doc-declare"><code>void mbedtls_ecp_set_max_ops( unsigned max_ops );</code></pre>
      <pre class="doc-comment">/**
 * \brief           Set the maximum number of basic operations done in a row.
 *
 *                  If more operations are needed to complete a computation,
 *                  #MBEDTLS_ERR_ECP_IN_PROGRESS will be returned by the
 *                  function performing the computation. It is then the
 *                  caller's responsibility to either call again with the same
 *                  parameters until it returns 0 or an error code; or to free
 *                  the restart context if the operation is to be aborted.
 *
 *                  It is strictly required that all input parameters and the
 *                  restart context be the same on successive calls for the
 *                  same operation, but output parameters need not be the
 *                  same; they must not be used until the function finally
 *                  returns 0.
 *
 *                  This only applies to functions whose documentation
 *                  mentions they may return #MBEDTLS_ERR_ECP_IN_PROGRESS (or
 *                  #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS for functions in the
 *                  SSL module). For functions that accept a "restart context"
 *                  argument, passing NULL disables restart and makes the
 *                  function equivalent to the function with the same name
 *                  with \c _restartable removed. For functions in the ECDH
 *                  module, restart is disabled unless the function accepts
 *                  an "ECDH context" argument and
 *                  mbedtls_ecdh_enable_restart() was previously called on
 *                  that context. For function in the SSL module, restart is
 *                  only enabled for specific sides and key exchanges
 *                  (currently only for clients and ECDHE-ECDSA).
 *
 * \param max_ops   Maximum number of basic operations done in a row.
 *                  Default: 0 (unlimited).
 *                  Lower (non-zero) values mean ECC functions will block for
 *                  a lesser maximum amount of time.
 *
 * \note            A "basic operation" is defined as a rough equivalent of a
 *                  multiplication in GF(p) for the NIST P-256 curve.
 *                  As an indication, with default settings, a scalar
 *                  multiplication (full run of \c mbedtls_ecp_mul()) is:
 *                  - about 3300 basic operations for P-256
 *                  - about 9400 basic operations for P-384
 *
 * \note            Very low values are not always respected: sometimes
 *                  functions need to block for a minimum number of
 *                  operations, and will do so even if max_ops is set to a
 *                  lower value.  That minimum depends on the curve size, and
 *                  can be made lower by decreasing the value of
 *                  \c MBEDTLS_ECP_WINDOW_SIZE.  As an indication, here is the
 *                  lowest effective value for various curves and values of
 *                  that parameter (w for short):
 *                          w=6     w=5     w=4     w=3     w=2
 *                  P-256   208     208     160     136     124
 *                  P-384   682     416     320     272     248
 *                  P-521  1364     832     640     544     496
 *
 * \note            This setting is currently ignored by Curve25519.
 */</pre>

      <h4 id="mbedtls_ecp_restart_is_enabled">Func <span>mbedtls_ecp_restart_is_enabled</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_restart_is_enabled( void );</code></pre>
      <pre class="doc-comment">/**
 * \brief           Check if restart is enabled (max_ops != 0)
 *
 * \return          \c 0 if \c max_ops == 0 (restart disabled)
 * \return          \c 1 otherwise (restart enabled)
 */</pre>

      <h4 id="mbedtls_ecp_point_init">Func <span>mbedtls_ecp_point_init</span></h4>
      <pre class="doc-declare"><code>void mbedtls_ecp_point_init( mbedtls_ecp_point *pt );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function initializes a point as zero.
 *
 * \param pt        The point to initialize.
 */</pre>

      <h4 id="mbedtls_ecp_group_init">Func <span>mbedtls_ecp_group_init</span></h4>
      <pre class="doc-declare"><code>void mbedtls_ecp_group_init( mbedtls_ecp_group *grp );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function initializes an ECP group context
 *                  without loading any domain parameters.
 *
 * \note            After this function is called, domain parameters
 *                  for various ECP groups can be loaded through the
 *                  mbedtls_ecp_group_load() or mbedtls_ecp_tls_read_group()
 *                  functions.
 */</pre>

      <h4 id="mbedtls_ecp_keypair_init">Func <span>mbedtls_ecp_keypair_init</span></h4>
      <pre class="doc-declare"><code>void mbedtls_ecp_keypair_init( mbedtls_ecp_keypair *key );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function initializes a key pair as an invalid one.
 *
 * \param key       The key pair to initialize.
 */</pre>

      <h4 id="mbedtls_ecp_point_free">Func <span>mbedtls_ecp_point_free</span></h4>
      <pre class="doc-declare"><code>void mbedtls_ecp_point_free( mbedtls_ecp_point *pt );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function frees the components of a point.
 *
 * \param pt        The point to free.
 */</pre>

      <h4 id="mbedtls_ecp_group_free">Func <span>mbedtls_ecp_group_free</span></h4>
      <pre class="doc-declare"><code>void mbedtls_ecp_group_free( mbedtls_ecp_group *grp );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function frees the components of an ECP group.
 *
 * \param grp       The group to free. This may be \c NULL, in which
 *                  case this function returns immediately. If it is not
 *                  \c NULL, it must point to an initialized ECP group.
 */</pre>

      <h4 id="mbedtls_ecp_keypair_free">Func <span>mbedtls_ecp_keypair_free</span></h4>
      <pre class="doc-declare"><code>void mbedtls_ecp_keypair_free( mbedtls_ecp_keypair *key );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function frees the components of a key pair.
 *
 * \param key       The key pair to free. This may be \c NULL, in which
 *                  case this function returns immediately. If it is not
 *                  \c NULL, it must point to an initialized ECP key pair.
 */</pre>

      <h4 id="mbedtls_ecp_restart_init">Func <span>mbedtls_ecp_restart_init</span></h4>
      <pre class="doc-declare"><code>void mbedtls_ecp_restart_init( mbedtls_ecp_restart_ctx *ctx );</code></pre>
      <pre class="doc-comment">/**
 * \brief           Initialize a restart context.
 *
 * \param ctx       The restart context to initialize. This must
 *                  not be \c NULL.
 */</pre>

      <h4 id="mbedtls_ecp_restart_free">Func <span>mbedtls_ecp_restart_free</span></h4>
      <pre class="doc-declare"><code>void mbedtls_ecp_restart_free( mbedtls_ecp_restart_ctx *ctx );</code></pre>
      <pre class="doc-comment">/**
 * \brief           Free the components of a restart context.
 *
 * \param ctx       The restart context to free. This may be \c NULL, in which
 *                  case this function returns immediately. If it is not
 *                  \c NULL, it must point to an initialized restart context.
 */</pre>

      <h4 id="mbedtls_ecp_copy">Func <span>mbedtls_ecp_copy</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_copy( mbedtls_ecp_point *P, const mbedtls_ecp_point *Q );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function copies the contents of point \p Q into
 *                  point \p P.
 *
 * \param P         The destination point. This must be initialized.
 * \param Q         The source point. This must be initialized.
 *
 * \return          \c 0 on success.
 * \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
 * \return          Another negative error code for other kinds of failure.
 */</pre>

      <h4 id="mbedtls_ecp_group_copy">Func <span>mbedtls_ecp_group_copy</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_group_copy( mbedtls_ecp_group *dst,
                           const mbedtls_ecp_group *src );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function copies the contents of group \p src into
 *                  group \p dst.
 *
 * \param dst       The destination group. This must be initialized.
 * \param src       The source group. This must be initialized.
 *
 * \return          \c 0 on success.
 * \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
 * \return          Another negative error code on other kinds of failure.
 */</pre>

      <h4 id="mbedtls_ecp_set_zero">Func <span>mbedtls_ecp_set_zero</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_set_zero( mbedtls_ecp_point *pt );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function sets a point to the point at infinity.
 *
 * \param pt        The point to set. This must be initialized.
 *
 * \return          \c 0 on success.
 * \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
 * \return          Another negative error code on other kinds of failure.
 */</pre>

      <h4 id="mbedtls_ecp_is_zero">Func <span>mbedtls_ecp_is_zero</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_is_zero( mbedtls_ecp_point *pt );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function checks if a point is the point at infinity.
 *
 * \param pt        The point to test. This must be initialized.
 *
 * \return          \c 1 if the point is zero.
 * \return          \c 0 if the point is non-zero.
 * \return          A negative error code on failure.
 */</pre>

      <h4 id="mbedtls_ecp_point_cmp">Func <span>mbedtls_ecp_point_cmp</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_point_cmp( const mbedtls_ecp_point *P,
                          const mbedtls_ecp_point *Q );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function compares two points.
 *
 * \note            This assumes that the points are normalized. Otherwise,
 *                  they may compare as "not equal" even if they are.
 *
 * \param P         The first point to compare. This must be initialized.
 * \param Q         The second point to compare. This must be initialized.
 *
 * \return          \c 0 if the points are equal.
 * \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the points are not equal.
 */</pre>

      <h4 id="mbedtls_ecp_point_read_string">Func <span>mbedtls_ecp_point_read_string</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_point_read_string( mbedtls_ecp_point *P, int radix,
                          const char *x, const char *y );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function imports a non-zero point from two ASCII
 *                  strings.
 *
 * \param P         The destination point. This must be initialized.
 * \param radix     The numeric base of the input.
 * \param x         The first affine coordinate, as a null-terminated string.
 * \param y         The second affine coordinate, as a null-terminated string.
 *
 * \return          \c 0 on success.
 * \return          An \c MBEDTLS_ERR_MPI_XXX error code on failure.
 */</pre>

      <h4 id="mbedtls_ecp_point_write_binary">Func <span>mbedtls_ecp_point_write_binary</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_point_write_binary( const mbedtls_ecp_group *grp, const mbedtls_ecp_point *P,
                           int format, size_t *olen,
                           unsigned char *buf, size_t buflen );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function exports a point into unsigned binary data.
 *
 * \param grp       The group to which the point should belong.
 *                  This must be initialized and have group parameters
 *                  set, for example through mbedtls_ecp_group_load().
 * \param P         The point to export. This must be initialized.
 * \param format    The point format. This must be either
 *                  #MBEDTLS_ECP_PF_COMPRESSED or #MBEDTLS_ECP_PF_UNCOMPRESSED.
 * \param olen      The address at which to store the length of
 *                  the output in Bytes. This must not be \c NULL.
 * \param buf       The output buffer. This must be a writable buffer
 *                  of length \p buflen Bytes.
 * \param buflen    The length of the output buffer \p buf in Bytes.
 *
 * \return          \c 0 on success.
 * \return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the output buffer
 *                  is too small to hold the point.
 * \return          Another negative error code on other kinds of failure.
 */</pre>

      <h4 id="mbedtls_ecp_point_read_binary">Func <span>mbedtls_ecp_point_read_binary</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_point_read_binary( const mbedtls_ecp_group *grp,
                                  mbedtls_ecp_point *P,
                                  const unsigned char *buf, size_t ilen );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function imports a point from unsigned binary data.
 *
 * \note            This function does not check that the point actually
 *                  belongs to the given group, see mbedtls_ecp_check_pubkey()
 *                  for that.
 *
 * \param grp       The group to which the point should belong.
 *                  This must be initialized and have group parameters
 *                  set, for example through mbedtls_ecp_group_load().
 * \param P         The destination context to import the point to.
 *                  This must be initialized.
 * \param buf       The input buffer. This must be a readable buffer
 *                  of length \p ilen Bytes.
 * \param ilen      The length of the input buffer \p buf in Bytes.
 *
 * \return          \c 0 on success.
 * \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the input is invalid.
 * \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
 * \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the point format
 *                  is not implemented.
 */</pre>

      <h4 id="mbedtls_ecp_tls_read_point">Func <span>mbedtls_ecp_tls_read_point</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_tls_read_point( const mbedtls_ecp_group *grp,
                               mbedtls_ecp_point *pt,
                               const unsigned char **buf, size_t len );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function imports a point from a TLS ECPoint record.
 *
 * \note            On function return, \p *buf is updated to point immediately
 *                  after the ECPoint record.
 *
 * \param grp       The ECP group to use.
 *                  This must be initialized and have group parameters
 *                  set, for example through mbedtls_ecp_group_load().
 * \param pt        The destination point.
 * \param buf       The address of the pointer to the start of the input buffer.
 * \param len       The length of the buffer.
 *
 * \return          \c 0 on success.
 * \return          An \c MBEDTLS_ERR_MPI_XXX error code on initialization
 *                  failure.
 * \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid.
 */</pre>

      <h4 id="mbedtls_ecp_tls_write_point">Func <span>mbedtls_ecp_tls_write_point</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_tls_write_point( const mbedtls_ecp_group *grp,
                                const mbedtls_ecp_point *pt,
                                int format, size_t *olen,
                                unsigned char *buf, size_t blen );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function exports a point as a TLS ECPoint record
 *                  defined in RFC 4492, Section 5.4.
 *
 * \param grp       The ECP group to use.
 *                  This must be initialized and have group parameters
 *                  set, for example through mbedtls_ecp_group_load().
 * \param pt        The point to be exported. This must be initialized.
 * \param format    The point format to use. This must be either
 *                  #MBEDTLS_ECP_PF_COMPRESSED or #MBEDTLS_ECP_PF_UNCOMPRESSED.
 * \param olen      The address at which to store the length in Bytes
 *                  of the data written.
 * \param buf       The target buffer. This must be a writable buffer of
 *                  length \p blen Bytes.
 * \param blen      The length of the target buffer \p buf in Bytes.
 *
 * \return          \c 0 on success.
 * \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the input is invalid.
 * \return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the target buffer
 *                  is too small to hold the exported point.
 * \return          Another negative error code on other kinds of failure.
 */</pre>

      <h4 id="mbedtls_ecp_group_load">Func <span>mbedtls_ecp_group_load</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_group_load( mbedtls_ecp_group *grp, mbedtls_ecp_group_id id );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function sets up an ECP group context
 *                  from a standardized set of domain parameters.
 *
 * \note            The index should be a value of the NamedCurve enum,
 *                  as defined in <em>RFC-4492: Elliptic Curve Cryptography
 *                  (ECC) Cipher Suites for Transport Layer Security (TLS)</em>,
 *                  usually in the form of an \c MBEDTLS_ECP_DP_XXX macro.
 *
 * \param grp       The group context to setup. This must be initialized.
 * \param id        The identifier of the domain parameter set to load.
 *
 * \return          \c 0 on success.
 * \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \p id doesn't
 *                  correspond to a known group.
 * \return          Another negative error code on other kinds of failure.
 */</pre>

      <h4 id="mbedtls_ecp_tls_read_group">Func <span>mbedtls_ecp_tls_read_group</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_tls_read_group( mbedtls_ecp_group *grp,
                               const unsigned char **buf, size_t len );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function sets up an ECP group context from a TLS
 *                  ECParameters record as defined in RFC 4492, Section 5.4.
 *
 * \note            The read pointer \p buf is updated to point right after
 *                  the ECParameters record on exit.
 *
 * \param grp       The group context to setup. This must be initialized.
 * \param buf       The address of the pointer to the start of the input buffer.
 * \param len       The length of the input buffer \c *buf in Bytes.
 *
 * \return          \c 0 on success.
 * \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid.
 * \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the group is not
 *                  recognized.
 * \return          Another negative error code on other kinds of failure.
 */</pre>

      <h4 id="mbedtls_ecp_tls_read_group_id">Func <span>mbedtls_ecp_tls_read_group_id</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_tls_read_group_id( mbedtls_ecp_group_id *grp,
                                  const unsigned char **buf,
                                  size_t len );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function extracts an elliptic curve group ID from a
 *                  TLS ECParameters record as defined in RFC 4492, Section 5.4.
 *
 * \note            The read pointer \p buf is updated to point right after
 *                  the ECParameters record on exit.
 *
 * \param grp       The address at which to store the group id.
 *                  This must not be \c NULL.
 * \param buf       The address of the pointer to the start of the input buffer.
 * \param len       The length of the input buffer \c *buf in Bytes.
 *
 * \return          \c 0 on success.
 * \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid.
 * \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the group is not
 *                  recognized.
 * \return          Another negative error code on other kinds of failure.
 */</pre>

      <h4 id="mbedtls_ecp_tls_write_group">Func <span>mbedtls_ecp_tls_write_group</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_tls_write_group( const mbedtls_ecp_group *grp,
                                size_t *olen,
                                unsigned char *buf, size_t blen );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function exports an elliptic curve as a TLS
 *                  ECParameters record as defined in RFC 4492, Section 5.4.
 *
 * \param grp       The ECP group to be exported.
 *                  This must be initialized and have group parameters
 *                  set, for example through mbedtls_ecp_group_load().
 * \param olen      The address at which to store the number of Bytes written.
 *                  This must not be \c NULL.
 * \param buf       The buffer to write to. This must be a writable buffer
 *                  of length \p blen Bytes.
 * \param blen      The length of the output buffer \p buf in Bytes.
 *
 * \return          \c 0 on success.
 * \return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the output
 *                  buffer is too small to hold the exported group.
 * \return          Another negative error code on other kinds of failure.
 */</pre>

      <h4 id="mbedtls_ecp_mul">Func <span>mbedtls_ecp_mul</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_mul( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
            const mbedtls_mpi *m, const mbedtls_ecp_point *P,
            int (*f_rng)(void *, unsigned char *, size_t), void *p_rng );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function performs a scalar multiplication of a point
 *                  by an integer: \p R = \p m * \p P.
 *
 *                  It is not thread-safe to use same group in multiple threads.
 *
 * \note            To prevent timing attacks, this function
 *                  executes the exact same sequence of base-field
 *                  operations for any valid \p m. It avoids any if-branch or
 *                  array index depending on the value of \p m.
 *
 * \note            If \p f_rng is not NULL, it is used to randomize
 *                  intermediate results to prevent potential timing attacks
 *                  targeting these results. We recommend always providing
 *                  a non-NULL \p f_rng. The overhead is negligible.
 *
 * \param grp       The ECP group to use.
 *                  This must be initialized and have group parameters
 *                  set, for example through mbedtls_ecp_group_load().
 * \param R         The point in which to store the result of the calculation.
 *                  This must be initialized.
 * \param m         The integer by which to multiply. This must be initialized.
 * \param P         The point to multiply. This must be initialized.
 * \param f_rng     The RNG function. This may be \c NULL if randomization
 *                  of intermediate results isn't desired (discouraged).
 * \param p_rng     The RNG context to be passed to \p p_rng.
 *
 * \return          \c 0 on success.
 * \return          #MBEDTLS_ERR_ECP_INVALID_KEY if \p m is not a valid private
 *                  key, or \p P is not a valid public key.
 * \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
 * \return          Another negative error code on other kinds of failure.
 */</pre>

      <h4 id="mbedtls_ecp_mul_restartable">Func <span>mbedtls_ecp_mul_restartable</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_mul_restartable( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
            const mbedtls_mpi *m, const mbedtls_ecp_point *P,
            int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
            mbedtls_ecp_restart_ctx *rs_ctx );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function performs multiplication of a point by
 *                  an integer: \p R = \p m * \p P in a restartable way.
 *
 * \see             mbedtls_ecp_mul()
 *
 * \note            This function does the same as \c mbedtls_ecp_mul(), but
 *                  it can return early and restart according to the limit set
 *                  with \c mbedtls_ecp_set_max_ops() to reduce blocking.
 *
 * \param grp       The ECP group to use.
 *                  This must be initialized and have group parameters
 *                  set, for example through mbedtls_ecp_group_load().
 * \param R         The point in which to store the result of the calculation.
 *                  This must be initialized.
 * \param m         The integer by which to multiply. This must be initialized.
 * \param P         The point to multiply. This must be initialized.
 * \param f_rng     The RNG function. This may be \c NULL if randomization
 *                  of intermediate results isn't desired (discouraged).
 * \param p_rng     The RNG context to be passed to \p p_rng.
 * \param rs_ctx    The restart context (NULL disables restart).
 *
 * \return          \c 0 on success.
 * \return          #MBEDTLS_ERR_ECP_INVALID_KEY if \p m is not a valid private
 *                  key, or \p P is not a valid public key.
 * \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
 * \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
 *                  operations was reached: see \c mbedtls_ecp_set_max_ops().
 * \return          Another negative error code on other kinds of failure.
 */</pre>

      <h4 id="mbedtls_ecp_muladd">Func <span>mbedtls_ecp_muladd</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_muladd( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
            const mbedtls_mpi *m, const mbedtls_ecp_point *P,
            const mbedtls_mpi *n, const mbedtls_ecp_point *Q );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function performs multiplication and addition of two
 *                  points by integers: \p R = \p m * \p P + \p n * \p Q
 *
 *                  It is not thread-safe to use same group in multiple threads.
 *
 * \note            In contrast to mbedtls_ecp_mul(), this function does not
 *                  guarantee a constant execution flow and timing.
 *
 * \param grp       The ECP group to use.
 *                  This must be initialized and have group parameters
 *                  set, for example through mbedtls_ecp_group_load().
 * \param R         The point in which to store the result of the calculation.
 *                  This must be initialized.
 * \param m         The integer by which to multiply \p P.
 *                  This must be initialized.
 * \param P         The point to multiply by \p m. This must be initialized.
 * \param n         The integer by which to multiply \p Q.
 *                  This must be initialized.
 * \param Q         The point to be multiplied by \p n.
 *                  This must be initialized.
 *
 * \return          \c 0 on success.
 * \return          #MBEDTLS_ERR_ECP_INVALID_KEY if \p m or \p n are not
 *                  valid private keys, or \p P or \p Q are not valid public
 *                  keys.
 * \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
 * \return          Another negative error code on other kinds of failure.
 */</pre>

      <h4 id="mbedtls_ecp_muladd_restartable">Func <span>mbedtls_ecp_muladd_restartable</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_muladd_restartable(
            mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
            const mbedtls_mpi *m, const mbedtls_ecp_point *P,
            const mbedtls_mpi *n, const mbedtls_ecp_point *Q,
            mbedtls_ecp_restart_ctx *rs_ctx );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function performs multiplication and addition of two
 *                  points by integers: \p R = \p m * \p P + \p n * \p Q in a
 *                  restartable way.
 *
 * \see             \c mbedtls_ecp_muladd()
 *
 * \note            This function works the same as \c mbedtls_ecp_muladd(),
 *                  but it can return early and restart according to the limit
 *                  set with \c mbedtls_ecp_set_max_ops() to reduce blocking.
 *
 * \param grp       The ECP group to use.
 *                  This must be initialized and have group parameters
 *                  set, for example through mbedtls_ecp_group_load().
 * \param R         The point in which to store the result of the calculation.
 *                  This must be initialized.
 * \param m         The integer by which to multiply \p P.
 *                  This must be initialized.
 * \param P         The point to multiply by \p m. This must be initialized.
 * \param n         The integer by which to multiply \p Q.
 *                  This must be initialized.
 * \param Q         The point to be multiplied by \p n.
 *                  This must be initialized.
 * \param rs_ctx    The restart context (NULL disables restart).
 *
 * \return          \c 0 on success.
 * \return          #MBEDTLS_ERR_ECP_INVALID_KEY if \p m or \p n are not
 *                  valid private keys, or \p P or \p Q are not valid public
 *                  keys.
 * \return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.
 * \return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of
 *                  operations was reached: see \c mbedtls_ecp_set_max_ops().
 * \return          Another negative error code on other kinds of failure.
 */</pre>

      <h4 id="mbedtls_ecp_check_pubkey">Func <span>mbedtls_ecp_check_pubkey</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_check_pubkey( const mbedtls_ecp_group *grp,
                             const mbedtls_ecp_point *pt );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function checks that a point is a valid public key
 *                  on this curve.
 *
 *                  It only checks that the point is non-zero, has
 *                  valid coordinates and lies on the curve. It does not verify
 *                  that it is indeed a multiple of \p G. This additional
 *                  check is computationally more expensive, is not required
 *                  by standards, and should not be necessary if the group
 *                  used has a small cofactor. In particular, it is useless for
 *                  the NIST groups which all have a cofactor of 1.
 *
 * \note            This function uses bare components rather than an
 *                  ::mbedtls_ecp_keypair structure, to ease use with other
 *                  structures, such as ::mbedtls_ecdh_context or
 *                  ::mbedtls_ecdsa_context.
 *
 * \param grp       The ECP group the point should belong to.
 *                  This must be initialized and have group parameters
 *                  set, for example through mbedtls_ecp_group_load().
 * \param pt        The point to check. This must be initialized.
 *
 * \return          \c 0 if the point is a valid public key.
 * \return          #MBEDTLS_ERR_ECP_INVALID_KEY if the point is not
 *                  a valid public key for the given curve.
 * \return          Another negative error code on other kinds of failure.
 */</pre>

      <h4 id="mbedtls_ecp_check_privkey">Func <span>mbedtls_ecp_check_privkey</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_check_privkey( const mbedtls_ecp_group *grp,
                              const mbedtls_mpi *d );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function checks that an \p mbedtls_mpi is a
 *                  valid private key for this curve.
 *
 * \note            This function uses bare components rather than an
 *                  ::mbedtls_ecp_keypair structure to ease use with other
 *                  structures, such as ::mbedtls_ecdh_context or
 *                  ::mbedtls_ecdsa_context.
 *
 * \param grp       The ECP group the private key should belong to.
 *                  This must be initialized and have group parameters
 *                  set, for example through mbedtls_ecp_group_load().
 * \param d         The integer to check. This must be initialized.
 *
 * \return          \c 0 if the point is a valid private key.
 * \return          #MBEDTLS_ERR_ECP_INVALID_KEY if the point is not a valid
 *                  private key for the given curve.
 * \return          Another negative error code on other kinds of failure.
 */</pre>

      <h4 id="mbedtls_ecp_gen_privkey">Func <span>mbedtls_ecp_gen_privkey</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_gen_privkey( const mbedtls_ecp_group *grp,
                    mbedtls_mpi *d,
                    int (*f_rng)(void *, unsigned char *, size_t),
                    void *p_rng );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function generates a private key.
 *
 * \param grp       The ECP group to generate a private key for.
 *                  This must be initialized and have group parameters
 *                  set, for example through mbedtls_ecp_group_load().
 * \param d         The destination MPI (secret part). This must be initialized.
 * \param f_rng     The RNG function. This must not be \c NULL.
 * \param p_rng     The RNG parameter to be passed to \p f_rng. This may be
 *                  \c NULL if \p f_rng doesn't need a context argument.
 *
 * \return          \c 0 on success.
 * \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX error code
 *                  on failure.
 */</pre>

      <h4 id="mbedtls_ecp_gen_keypair_base">Func <span>mbedtls_ecp_gen_keypair_base</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_gen_keypair_base( mbedtls_ecp_group *grp,
                                 const mbedtls_ecp_point *G,
                                 mbedtls_mpi *d, mbedtls_ecp_point *Q,
                                 int (*f_rng)(void *, unsigned char *, size_t),
                                 void *p_rng );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function generates a keypair with a configurable base
 *                  point.
 *
 * \note            This function uses bare components rather than an
 *                  ::mbedtls_ecp_keypair structure to ease use with other
 *                  structures, such as ::mbedtls_ecdh_context or
 *                  ::mbedtls_ecdsa_context.
 *
 * \param grp       The ECP group to generate a key pair for.
 *                  This must be initialized and have group parameters
 *                  set, for example through mbedtls_ecp_group_load().
 * \param G         The base point to use. This must be initialized
 *                  and belong to \p grp. It replaces the default base
 *                  point \c grp->G used by mbedtls_ecp_gen_keypair().
 * \param d         The destination MPI (secret part).
 *                  This must be initialized.
 * \param Q         The destination point (public part).
 *                  This must be initialized.
 * \param f_rng     The RNG function. This must not be \c NULL.
 * \param p_rng     The RNG context to be passed to \p f_rng. This may
 *                  be \c NULL if \p f_rng doesn't need a context argument.
 *
 * \return          \c 0 on success.
 * \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX error code
 *                  on failure.
 */</pre>

      <h4 id="mbedtls_ecp_gen_keypair">Func <span>mbedtls_ecp_gen_keypair</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_gen_keypair( mbedtls_ecp_group *grp, mbedtls_mpi *d,
                            mbedtls_ecp_point *Q,
                            int (*f_rng)(void *, unsigned char *, size_t),
                            void *p_rng );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function generates an ECP keypair.
 *
 * \note            This function uses bare components rather than an
 *                  ::mbedtls_ecp_keypair structure to ease use with other
 *                  structures, such as ::mbedtls_ecdh_context or
 *                  ::mbedtls_ecdsa_context.
 *
 * \param grp       The ECP group to generate a key pair for.
 *                  This must be initialized and have group parameters
 *                  set, for example through mbedtls_ecp_group_load().
 * \param d         The destination MPI (secret part).
 *                  This must be initialized.
 * \param Q         The destination point (public part).
 *                  This must be initialized.
 * \param f_rng     The RNG function. This must not be \c NULL.
 * \param p_rng     The RNG context to be passed to \p f_rng. This may
 *                  be \c NULL if \p f_rng doesn't need a context argument.
 *
 * \return          \c 0 on success.
 * \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX error code
 *                  on failure.
 */</pre>

      <h4 id="mbedtls_ecp_gen_key">Func <span>mbedtls_ecp_gen_key</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_gen_key( mbedtls_ecp_group_id grp_id, mbedtls_ecp_keypair *key,
                        int (*f_rng)(void *, unsigned char *, size_t),
                        void *p_rng );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function generates an ECP key.
 *
 * \param grp_id    The ECP group identifier.
 * \param key       The destination key. This must be initialized.
 * \param f_rng     The RNG function to use. This must not be \c NULL.
 * \param p_rng     The RNG context to be passed to \p f_rng. This may
 *                  be \c NULL if \p f_rng doesn't need a context argument.
 *
 * \return          \c 0 on success.
 * \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX error code
 *                  on failure.
 */</pre>

      <h4 id="mbedtls_ecp_check_pub_priv">Func <span>mbedtls_ecp_check_pub_priv</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_check_pub_priv( const mbedtls_ecp_keypair *pub,
                               const mbedtls_ecp_keypair *prv );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function checks that the keypair objects
 *                  \p pub and \p prv have the same group and the
 *                  same public point, and that the private key in
 *                  \p prv is consistent with the public key.
 *
 * \param pub       The keypair structure holding the public key. This
 *                  must be initialized. If it contains a private key, that
 *                  part is ignored.
 * \param prv       The keypair structure holding the full keypair.
 *                  This must be initialized.
 *
 * \return          \c 0 on success, meaning that the keys are valid and match.
 * \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the keys are invalid or do not match.
 * \return          An \c MBEDTLS_ERR_ECP_XXX or an \c MBEDTLS_ERR_MPI_XXX
 *                  error code on calculation failure.
 */</pre>

      <h4 id="mbedtls_ecp_self_test">Func <span>mbedtls_ecp_self_test</span></h4>
      <pre class="doc-declare"><code>int mbedtls_ecp_self_test( int verbose );</code></pre>
      <pre class="doc-comment">/**
 * \brief          The ECP checkup routine.
 *
 * \return         \c 0 on success.
 * \return         \c 1 on failure.
 */</pre>
      <h3 id="vars">Vars</h3>
      
      <h3 id="consts">Consts</h3>
      

      <h4 id=" ">Const <span> </span></h4>
      <pre class="doc-declare"><code>const mbedtls_ecp_curve_info *mbedtls_ecp_curve_list( void );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function retrieves the information defined in
 *                  mbedtls_ecp_curve_info() for all supported curves in order
 *                  of preference.
 *
 * \return          A statically allocated array. The last entry is 0.
 */</pre>

      <h4 id=" ">Const <span> </span></h4>
      <pre class="doc-declare"><code>const mbedtls_ecp_group_id *mbedtls_ecp_grp_id_list( void );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function retrieves the list of internal group
 *                  identifiers of all supported curves in the order of
 *                  preference.
 *
 * \return          A statically allocated array,
 *                  terminated with MBEDTLS_ECP_DP_NONE.
 */</pre>

      <h4 id=" ">Const <span> </span></h4>
      <pre class="doc-declare"><code>const mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_grp_id( mbedtls_ecp_group_id grp_id );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function retrieves curve information from an internal
 *                  group identifier.
 *
 * \param grp_id    An \c MBEDTLS_ECP_DP_XXX value.
 *
 * \return          The associated curve information on success.
 * \return          NULL on failure.
 */</pre>

      <h4 id=" ">Const <span> </span></h4>
      <pre class="doc-declare"><code>const mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_tls_id( uint16_t tls_id );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function retrieves curve information from a TLS
 *                  NamedCurve value.
 *
 * \param tls_id    An \c MBEDTLS_ECP_DP_XXX value.
 *
 * \return          The associated curve information on success.
 * \return          NULL on failure.
 */</pre>

      <h4 id=" ">Const <span> </span></h4>
      <pre class="doc-declare"><code>const mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_name( const char *name );</code></pre>
      <pre class="doc-comment">/**
 * \brief           This function retrieves curve information from a
 *                  human-readable name.
 *
 * \param name      The human-readable name.
 *
 * \return          The associated curve information on success.
 * \return          NULL on failure.
 */</pre>
      <h3 id="types">Types</h3>
      
      <h3 id="typedefs">Typedefs</h3>
      

      <h4 id="mbedtls_ecp_group_id;
">Typedef <span>mbedtls_ecp_group_id;
</span></h4>
      <pre class="doc-declare"><code>typedef enum
{
   MBEDTLS_ECP_DP_NONE = 0,      /*!< Curve not defined. */
   MBEDTLS_ECP_DP_SECP192R1,     /*!< Domain parameters for the 192-bit curve defined by FIPS 186-4 and SEC1. */
   MBEDTLS_ECP_DP_SECP224R1,     /*!< Domain parameters for the 224-bit curve defined by FIPS 186-4 and SEC1. */
   MBEDTLS_ECP_DP_SECP256R1,     /*!< Domain parameters for the 256-bit curve defined by FIPS 186-4 and SEC1. */
   MBEDTLS_ECP_DP_SECP384R1,     /*!< Domain parameters for the 384-bit curve defined by FIPS 186-4 and SEC1. */
   MBEDTLS_ECP_DP_SECP521R1,     /*!< Domain parameters for the 521-bit curve defined by FIPS 186-4 and SEC1. */
   MBEDTLS_ECP_DP_BP256R1,       /*!< Domain parameters for 256-bit Brainpool curve. */
   MBEDTLS_ECP_DP_BP384R1,       /*!< Domain parameters for 384-bit Brainpool curve. */
   MBEDTLS_ECP_DP_BP512R1,       /*!< Domain parameters for 512-bit Brainpool curve. */
   MBEDTLS_ECP_DP_CURVE25519,    /*!< Domain parameters for Curve25519. */
   MBEDTLS_ECP_DP_SECP192K1,     /*!< Domain parameters for 192-bit "Koblitz" curve. */
   MBEDTLS_ECP_DP_SECP224K1,     /*!< Domain parameters for 224-bit "Koblitz" curve. */
   MBEDTLS_ECP_DP_SECP256K1,     /*!< Domain parameters for 256-bit "Koblitz" curve. */
   MBEDTLS_ECP_DP_CURVE448,      /*!< Domain parameters for Curve448. */
} mbedtls_ecp_group_id;
</code></pre>
      <pre class="doc-comment">/**
 * Domain-parameter identifiers: curve, subgroup, and generator.
 *
 * \note Only curves over prime fields are supported.
 *
 * \warning This library does not support validation of arbitrary domain
 * parameters. Therefore, only standardized domain parameters from trusted
 * sources should be used. See mbedtls_ecp_group_load().
 */</pre>

      <h4 id="mbedtls_ecp_curve_info;
">Typedef <span>mbedtls_ecp_curve_info;
</span></h4>
      <pre class="doc-declare"><code>typedef struct mbedtls_ecp_curve_info
{
   mbedtls_ecp_group_id grp_id;   /*!< An internal identifier. */
   uint16_t tls_id;               /*!< The TLS NamedCurve identifier. */
   uint16_t bit_size;             /*!< The curve size in bits. */
   const char *name;              /*!< A human-friendly name. */
} mbedtls_ecp_curve_info;
</code></pre>
      <pre class="doc-comment">/**
 * Curve information, for use by other modules.
 */</pre>

      <h4 id="
mbedtls_ecp_point;
">Typedef <span>
mbedtls_ecp_point;
</span></h4>
      <pre class="doc-declare"><code>typedef struct mbedtls_ecp_point
{
   mbedtls_mpi X;         /*!< The X coordinate of the ECP point. */
   mbedtls_mpi Y;         /*!< The Y coordinate of the ECP point. */
   mbedtls_mpi Z;         /*!< The Z coordinate of the ECP point. */
}
mbedtls_ecp_point;
</code></pre>
      <pre class="doc-comment">/**
 * \brief           The ECP point structure, in Jacobian coordinates.
 *
 * \note            All functions expect and return points satisfying
 *                  the following condition: <code>Z == 0</code> or
 *                  <code>Z == 1</code>. Other values of \p Z are
 *                  used only by internal functions.
 *                  The point is zero, or "at infinity", if <code>Z == 0</code>.
 *                  Otherwise, \p X and \p Y are its standard (affine)
 *                  coordinates.
 */</pre>

      <h4 id="
mbedtls_ecp_group;
">Typedef <span>
mbedtls_ecp_group;
</span></h4>
      <pre class="doc-declare"><code>typedef struct mbedtls_ecp_group
{
   mbedtls_ecp_group_id id;   /*!< An internal group identifier. */
   mbedtls_mpi P;             /*!< The prime modulus of the base field. */
   mbedtls_mpi A;             /*!< For Short Weierstrass: \p A in the equation. For
                                     Montgomery curves: <code>(A + 2) / 4</code>. */
   mbedtls_mpi B;             /*!< For Short Weierstrass: \p B in the equation.
                                     For Montgomery curves: unused. */
   mbedtls_ecp_point G;       /*!< The generator of the subgroup used. */
   mbedtls_mpi N;             /*!< The order of \p G. */
   size_t pbits;              /*!< The number of bits in \p P.*/
   size_t nbits;              /*!< For Short Weierstrass: The number of bits in \p P.
                                     For Montgomery curves: the number of bits in the
                                     private keys. */
   unsigned int h;            /*!< \internal 1 if the constants are static. */
   int (*modp)(mbedtls_mpi *); /*!< The function for fast pseudo-reduction
                                     mod \p P (see above).*/
   int (*t_pre)(mbedtls_ecp_point *, void *); /*!< Unused. */
   int (*t_post)(mbedtls_ecp_point *, void *); /*!< Unused. */
   void *t_data;              /*!< Unused. */
   mbedtls_ecp_point *T;      /*!< Pre-computed points for ecp_mul_comb(). */
   size_t T_size;             /*!< The number of pre-computed points. */
}
mbedtls_ecp_group;
</code></pre>
      <pre class="doc-comment">/**
 * \brief           The ECP group structure.
 *
 * We consider two types of curve equations:
 * <ul><li>Short Weierstrass: <code>y^2 = x^3 + A x + B mod P</code>
 * (SEC1 + RFC-4492)</li>
 * <li>Montgomery: <code>y^2 = x^3 + A x^2 + x mod P</code> (Curve25519,
 * Curve448)</li></ul>
 * In both cases, the generator (\p G) for a prime-order subgroup is fixed.
 *
 * For Short Weierstrass, this subgroup is the whole curve, and its
 * cardinality is denoted by \p N. Our code requires that \p N is an
 * odd prime as mbedtls_ecp_mul() requires an odd number, and
 * mbedtls_ecdsa_sign() requires that it is prime for blinding purposes.
 *
 * For Montgomery curves, we do not store \p A, but <code>(A + 2) / 4</code>,
 * which is the quantity used in the formulas. Additionally, \p nbits is
 * not the size of \p N but the required size for private keys.
 *
 * If \p modp is NULL, reduction modulo \p P is done using a generic algorithm.
 * Otherwise, \p modp must point to a function that takes an \p mbedtls_mpi in the
 * range of <code>0..2^(2*pbits)-1</code>, and transforms it in-place to an integer
 * which is congruent mod \p P to the given MPI, and is close enough to \p pbits
 * in size, so that it may be efficiently brought in the 0..P-1 range by a few
 * additions or subtractions. Therefore, it is only an approximative modular
 * reduction. It must return 0 on success and non-zero on failure.
 *
 * \note        Alternative implementations must keep the group IDs distinct. If
 *              two group structures have the same ID, then they must be
 *              identical.
 *
 */</pre>

      <h4 id="mbedtls_ecp_restart_mul_ctx">Typedef <span>mbedtls_ecp_restart_mul_ctx</span></h4>
      <pre class="doc-declare"><code>typedef struct mbedtls_ecp_restart_mul mbedtls_ecp_restart_mul_ctx;
</code></pre>
      <pre class="doc-comment">/**
 * \brief           Internal restart context for multiplication
 *
 * \note            Opaque struct
 */</pre>

      <h4 id="mbedtls_ecp_restart_muladd_ctx">Typedef <span>mbedtls_ecp_restart_muladd_ctx</span></h4>
      <pre class="doc-declare"><code>typedef struct mbedtls_ecp_restart_muladd mbedtls_ecp_restart_muladd_ctx;
</code></pre>
      <pre class="doc-comment">/**
 * \brief           Internal restart context for ecp_muladd()
 *
 * \note            Opaque struct
 */</pre>

      <h4 id="mbedtls_ecp_restart_ctx;
">Typedef <span>mbedtls_ecp_restart_ctx;
</span></h4>
      <pre class="doc-declare"><code>typedef struct
{
   unsigned ops_done;                 /*!<  current ops count             */
   unsigned depth;                    /*!<  call depth (0 = top-level)    */
   mbedtls_ecp_restart_mul_ctx *rsm;  /*!<  ecp_mul_comb() sub-context    */
   mbedtls_ecp_restart_muladd_ctx *ma; /*!<  ecp_muladd() sub-context      */
} mbedtls_ecp_restart_ctx;
</code></pre>
      <pre class="doc-comment">/**
 * \brief           General context for resuming ECC operations
 */</pre>

      <h4 id="mbedtls_ecp_restart_ctx">Typedef <span>mbedtls_ecp_restart_ctx</span></h4>
      <pre class="doc-declare"><code>typedef void mbedtls_ecp_restart_ctx;
</code></pre>
      <pre class="doc-comment">/* We want to declare restartable versions of existing functions anyway */</pre>

      <h4 id="
mbedtls_ecp_keypair;
">Typedef <span>
mbedtls_ecp_keypair;
</span></h4>
      <pre class="doc-declare"><code>typedef struct mbedtls_ecp_keypair
{
   mbedtls_ecp_group grp;     /*!<  Elliptic curve and base point     */
   mbedtls_mpi d;             /*!<  our secret value                  */
   mbedtls_ecp_point Q;       /*!<  our public value                  */
}
mbedtls_ecp_keypair;
</code></pre>
      <pre class="doc-comment">/**
 * \brief    The ECP key-pair structure.
 *
 * A generic key-pair that may be used for ECDSA and fixed ECDH, for example.
 *
 * \note    Members are deliberately in the same order as in the
 *          ::mbedtls_ecdsa_context structure.
 */</pre>
    </div>
  </body>
</html>
            